#include <iostream>
#include <vector>
// second code 
class FlipFlop {
protected:
    bool Q;
    bool Q_bar;
public:
    FlipFlop() : Q(false), Q_bar(true) {}
    virtual void clock(bool set, bool reset, bool clock, bool data) = 0;
    bool getQ() const { return Q; }
    void displayOutput() const {
        std::cout << "Q = " << Q << ", Q' = " << Q_bar << std::endl;
    }
};

class DFlipFlop : public FlipFlop {
public:
    void clock(bool set, bool reset, bool clock, bool data) override {
        if (reset) {
            Q = false;
            Q_bar = true;
        } else if (set) {
            Q = true;
            Q_bar = false;
        } else if (clock) {
            Q = data;
            Q_bar = !data;
        }
    }
};

class SequentialCircuitSimulator {
private:
    std::vector<DFlipFlop> flipFlops;
public:
    SequentialCircuitSimulator(int numberOfFlipFlops) {
        flipFlops.resize(numberOfFlipFlops);
    }

    void simulateShiftRegister(int clockCycles, const std::vector<bool>& dataInputs) {
        int dataIndex = 0;
        for (int cycle = 0; cycle < clockCycles; ++cycle) {
            bool input = dataIndex < dataInputs.size() ? dataInputs[dataIndex++] : false;
            bool previousQ = input;
            
            for (auto& flipFlop : flipFlops) {
                bool currentQ = flipFlop.getQ();
                flipFlop.clock(false, false, true, previousQ);
                previousQ = currentQ;
            }

            std::cout << "After clock cycle " << cycle + 1 << ":" << std::endl;
            displayShiftRegisterState();
        }
    }

    void displayShiftRegisterState() const {
        for (size_t i = 0; i < flipFlops.size(); ++i) {
            std::cout << "Flip-Flop " << i + 1 << ": ";
            flipFlops[i].displayOutput();
        }
    }
};

int main() {
    int numberOfFlipFlops;
    int clockCycles;
    std::vector<bool> dataInputs;
    int input;

    std::cout << "Enter the number of D Flip-Flops in the shift register: ";
    std::cin >> numberOfFlipFlops;

    std::cout << "Enter the number of clock cycles to simulate: ";
    std::cin >> clockCycles;

    std::cout << "Enter the data inputs (0 or 1) for each clock cycle (enter -1 to stop): ";
    while (std::cin >> input && input != -1) {
        dataInputs.push_back(input);
    }

    SequentialCircuitSimulator simulator(numberOfFlipFlops);
    simulator.simulateShiftRegister(clockCycles, dataInputs);

    return 0;
}

//verilog
module D_FF(
    input signed  [7:0]d,
    input clk,
    input reset,
    output reg signed [15:0]q
    );
    
always@(posedge clk or posedge reset) 

begin
    if(reset==1'b1)
    q <=1'b0;
    else
    q<=d;    
end 
endmodule

module FIR_2_ORDER(
    input clk,
    input reset,
    input signed [7:0]X,
    output reg signed  [15:0]Y
    );
    
    
    wire signed [15:0] a,b,c ;
    assign a=16'd10;
    assign b=16'd44;
    assign c=16'd10;
    wire signed  [15:0]m1,m2,m3;
    wire signed  [7:0]d11,d12;
    wire signed  [15:0]d1,d2;
    assign m1= (X*a);
    D_FF inst1(
                .clk(clk),
                .reset(reset),
                .d(X),
                .q(d11)
               );
   assign m2= (d11*b);
   assign d1= (m1+m2);
   D_FF inst2(
           .clk(clk),
           .reset(reset),
           .d(d11),
           .q(d12)
          );
   assign m3= (d12*c);
   assign d2= (d1+m3); 
 always @(X)begin 
 Y <= d2 ;
 end   
endmodule

module FIR_1_tb();
    reg clk,reset;
    reg signed [7:0]X;
    wire signed [15:0]Y;
    
FIR_2_ORDER uut(
                    .clk(clk),
                    .reset(reset),
                    .X(X),
                    .Y(Y)
                );

initial 
clk=0;
always #1 clk=~clk;


initial begin
X=2;reset=1'b0;#5;
X=22;reset=1'b0;#5;
X=7;reset=1'b0;#5;
X=27;reset=1'b0;#5;
X=26;reset=1'b0;#5;




 
